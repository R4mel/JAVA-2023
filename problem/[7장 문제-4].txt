[7장 문제-4]
/******************************************************************************
 * 코드 추가 2
 ******************************************************************************/
// 자주 메모 메뉴까지 진입해야 하는 번거로움을 피하기 위해 
// 1) 기존의 MainMenu::run() 함수 전체를 주석 처리하라.
// 2) 아래 함수를 그 뒤에 배치하라. 임시로 이 함수를 사용할 예정이다.
//-----------------------------------------------------------------------------
    public static void run() {
        new Memo("").run();
    }
//-----------------------------------------------------------------------------


/******************************************************************************
 * 문제: 1
 * 요점: String, Map을 활용하는 문제
 ******************************************************************************/
// Memo::wordCount() 함수를 구현하라.
// 이 함수는 mStr에 들어 있는 각 단어별 출현 횟수를 출력한다. 
// 아래 실행 결과를 먼저 참고하고, [문제 1-1]과 [문제 1-2]을 해결하라.

===============================================================================
==  문제 1 실행 결과
===============================================================================

+++++++++++++++++++++ Memo Management Menu +++++++++++++++++++
+ 0.exit 1.display 2.find 3.findReplace 4.compare 5.dispByLn +
+ 6.delLn 7.replLn 8.scrollUp 9.scrollDown 10.inputMemo      +
+ 11.wordCount 12.countWordList                              +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
menu item? 11
----------------
Word      Count
----------------
-          21
EIGHT       8
Indian      2
and         2
eight       8
five        5
four        4
greater     2
in          4
is          2
much        2
of          5
seven       7
six         6
so          3
ten        10
the         9
three       3
to          3
----------------

/******************************************************************************
 * 문제 1-1
 ******************************************************************************/
// 먼저 아래 getWordCountMap() 함수를 Memo::wordCount() 함수 앞에 배치하고,
// ToDo 부분의 주석을 참고하여 코드를 완성하라.
//-----------------------------------------------------------------------------
// 이 함수는 Memo::mStr에 들어 있는 문자열을 빼내 이를 단어 단위로 토큰을 자른 후 
// 각 단어별 출현 횟수를 Map에 저장한 후 해당 Map을 반환한다. 
// 리턴 데이터 타입인 Map< String, Integer >에서 String은 단어이며, 
// Integer는 해당 단어의 출현 횟수이다. 반환하는 Map으로는 TreeMap 또는 HashMap 중에서
// 단어별 정렬이 미리 되어 있는 적절한 Map을 생성해서 리턴해야 한다.
//-----------------------------------------------------------------------------
    private Map< String, Integer > getWordCountMap() { // ch7_3
        /* ToDo:
        mStr에서 전체를 하나의 문자열로 빼낸다. (compare() 함수 참고)
        이 문자열을 공백문자("\\s")를 구분자로 해서 토큰을 자른 후 문자열 배열인 words 저장한다.
        문제의 목적(단어별 정렬이 미리 되어 있는)에 맞는 <단어, 출현횟수>를 저장할 수 있는 
            적절한 Map을 생성해서 wordCountMap에 저장한다.
        for-each 문을 이용하여 words의 각 단어 w에 대해
    		빈 문자열("")이 있을 수 있으므로 w가 빈 문자열인 경우 스킵한다.
    		wordCountMap에서 단어 w를 검색한다. 검색된 값은 출현 횟수인 Integer 객체이다.
    		검색 성공 실패는 교제 예제 7-5를 참고하라.
    		검색 실패면(처음 삽입 시) 횟수 1을 그냥 맵에 삽입한다. (그냥 숫자 1을 삽입하면 된다.)
    		검색에 성공했으면 기존 횟수를 1 증가시켜 다시 맵에 삽입한다. 
    		(Integer 객체에 대해 ++ 또는 += 연산자 적용 가능함)
    	}
    	return wordCountMap; // Map으로 자동 업 케스팅되어 리턴됨
    }
//-----------------------------------------------------------------------------

/******************************************************************************
 * 문제 1-2
 ******************************************************************************/
// 기존 wordCount()를 아래 내용으로 교체하고 ToDo 부분을 참고하여 코드를 완성하라.
//-----------------------------------------------------------------------------
// 이 함수 구현 시 아래 getWordCountMap()를 호출하여 
// mStr에 들어 있는 각 단어별 출현 횟수를 저장하고 있는 Map을 구한다. 
// Map에 있는 모든 단어들을 사전적 순서로 출력하되 실행결과처럼 단어와 그 단어의 출현횟수를 출력한다. 
// 단, 출현 횟수가 1인 단어는 출력하지 마라.
//-----------------------------------------------------------------------------
    void wordCount() { // Menu item 11
        var wordCountMap = getWordCountMap();
        System.out.println("----------------");
        System.out.println("Word      Count");
        System.out.println("----------------");
        /* 
        ToDo: PMbyMap::display(map)을 참고하여 아래를 구현하라.
        1) 위 wordCountMap의 엔트리 집합을 구해서 wcEntries에 저장하라.
               엔트리 집합 wcEntries은 Set< Map.Entry< String, Integer > > 타입이어야 한다.
               각 엔트리는 <단어, 단어의 출현횟수>이다. 
        2) for-each 문을 이용하여 엔트리 집합 wcEntries의 각 엔트리 wc에 대해
               wc에서 키(단어, word)와 값(단어 출현 횟수, count)을 구한 후 
               (PMbyMap::display(map)을 참고할 것) 이를 아래처럼 출력한다.
               if (count > 1)  // %-7s: 문자열을 7 칸 안에 출력하되 좌 맞춤
                   System.out.printf("%-7s    %2d\n", word, count);
        */
        System.out.println("----------------");
    }
//-----------------------------------------------------------------------------


/******************************************************************************
 * 문제: 2
 * 요점: String, Vector, Map을 활용하는 종합 문제
 ******************************************************************************/
// Memo::countWordList() 함수를 구현하라. 
//-----------------------------------------------------------------------------
// 이 함수는 mStr에 들어 있는 단어의 출현 횟수가 많은 단어를 순서적으로 출력한다.
// 출현 횟수가 동일한 단어들은 모두 한 행에 출력한다.
// 단, 출현 횟수가 1인 단어들은 출력하지 마라.
// 아래 실행 결과를 먼저 참고하고, [문제 2 구현 방법]을 참고하여 구현하라.

===============================================================================
==  문제 2 실행 결과
===============================================================================

+++++++++++++++++++++ Memo Management Menu +++++++++++++++++++
+ 0.exit 1.display 2.find 3.findReplace 4.compare 5.dispByLn +
+ 6.delLn 7.replLn 8.scrollUp 9.scrollDown 10.inputMemo      +
+ 11.wordCount 12.countWordList                              +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
menu item? 12
----------------
Count  Words
----------------
21     - 
10     ten 
 9     the 
 8     EIGHT eight 
 7     seven 
 6     six 
 5     five of 
 4     four in 
 3     so three to 
 2     Indian and greater is much 
----------------

/******************************************************************************
 * 문제 2 구현 방법
 ******************************************************************************/
// 기존 countWordList()를 아래 내용으로 교체하고 ToDo 부분을 참고하여 코드를 완성하라.
//-----------------------------------------------------------------------------
    void countWordList() {
        var wordCountMap = getWordCountMap();

        /* ToDo: 먼저 구현한 wordCount()을 참고하여 아래를 구현하라.
        1) 위 wordCountMap의 엔트리 집합을 구해서 wcEntries에 저장하라.
        2) 키는 (단어의 출현 회수)이고, 값은 (동일한 출현 횟수를 가진 단어들을 저장할 수 있는 Vector)인
           Map을 생성하여 countWordsMap에 저장한다.
           즉, 이 맵의 엔트리는 < Integer, Vector< String > > 이다.
           이때 생성할 맵은 출현 횟수별로 정렬이 되어 있는 맵을 선택해야 한다.(작은 수에 큰 수로 정렬) 
        3) for-each 문을 이용하여 엔트리 집합 wcEntries의 각 엔트리 wc에 대해
               wc에서 키인 word와 값인 count를 구한다.
               count를 키로 사용해서 countWordsMap의 값인 wordVct 벡터를 검색한다.
               만약 검색에 실패 했다면 (처음 삽입 시)
                   문자열 백터를 새로 생성하여 wordVct에 저장한다.
                   wordVct를 countWordsMap에 삽입한다.
               wordVct에 word를 삽입한다.
        */
        System.out.println("----------------");
        System.out.println("Count  Words");
        System.out.println("----------------");

        // 아래는 키의 순서를 역순으로 재배치한 새로운 맵 reverseCWMap을 생성한다.
        // 이 맵은 단어의 출현 횟수가 큰 수부터 작은 수 순서로 횟수를 저장하고 있다.
        var reverseCWMap = countWordsMap.descendingMap();
        
        /* ToDo:
        1) 위 reverseCWMap의 엔트리 집합을 구해서 cwEntries에 저장하라.
        2) for-each 문을 이용하여 엔트리 집합 cwEntries의 각 엔트리 cw에 대해
               cw에서 키인 count를 구한다.
               count가 1이면 스킵한다.
               System.out.printf("%2d     ", count);
               cw에서 값인 wordVct 벡터를 구한다.
               for-each 문을 이용하여 벡터 wordVct의 각 원소 w에 대해
                   System.out.print(w+ " ");
               System.out.println();
        */
        System.out.println("----------------");
    }
//-----------------------------------------------------------------------------


/******************************************************************************
 * 코드 복원
 ******************************************************************************/
// 1) 임시로 사용했던 임시로 MainMenu::run()을 삭제하라.
// 2) 주석 처리된 기존 MainMenu::run() 함수 전체의 주석을 해제하라.
//-----------------------------------------------------------------------------